# Educational Codeforces Round 93 (CF1398) 题解

## Problem A - Bad Triangle

### 题目描述

给定一个升序数组$a$，找出任意一个三元组$(i,j,k)$（$i<j<k$）使得$a_i,a_j,a_k$不能构成三角形。

### 题解

贪心选取最小的两个数和最大的数，如果它们可以构成三角形，那么本题无解；否则它们就是一组合法的解。

::: spoiler 参考代码（C++）

<<< @/docs/editorial/codeforces/1398/src/a.cpp

:::

## Problem B - Substring Removal Game

### 题目描述

给定一个01字符串，A、B两人玩游戏，每次每人可以取走任意一段连续相同的字符，A先动，问最多可以取到多少个1。

### 题解

显然每次选取都会选择当前最长的1串。所以只要找出所有的1串，按长度降序排列，然后累加奇数项即为答案。

::: spoiler 参考代码（C++）

<<< @/docs/editorial/codeforces/1398/src/b.cpp

:::

## Problem C - Good Subarrays

### 题目描述

给定数组$a$（以一个大整数的形式给出），问$a$有多少个子数组满足元素之和等于子数组长度。

### 题解

如果将所有元素都减去1，那么要求的子数组就变成了和为0的子数组，进而可以用前缀哈希的方法来解决。

::: spoiler 参考代码（C++）

<<< @/docs/editorial/codeforces/1398/src/c.cpp

:::

## Problem D - Colored Rectangles

### 题目描述

给定红绿蓝三种木条，分别有$R$对，$G$对，$B$对，要求每次取出两对不同颜色的木条组成矩形，求能够组成的矩形的最大总面积。

### 题解

显然每种颜色的木条应该先用长的再用短的，但是具体用哪两种颜色并不容易确定。考虑到数据范围（$R,G,B\leq200$），使用动态规划来求解。$dp[i][j][k]$表示用了$i$对红色，$j$对绿色，$k$对蓝色时的最大面积，转移很简单，分别枚举三种取法即可。

::: spoiler 参考代码（C++）

<<< @/docs/editorial/codeforces/1398/src/d.cpp

:::

## Problem E - Two Types of Spells

### 题目描述

有火焰和闪电两种咒语，它们都有能量值，同时闪电咒语还有一个额外效果，可以让下一个咒语的能量值翻倍。现在有$N$次询问，每次会增加或删除一个咒语（保证任意时刻不会有相同能量值的咒语），在每次询问后，给出当前所有咒语排列可以得到的最大能量值。

### 题解

可以发现，如果当前有$K$个闪电咒语，那么就可以有$K$个咒语的能量值翻倍（除非一共只有$K$个咒语），但有一条限制，就是这$K$个咒语不能都为闪电咒语（第一个闪电咒语无法翻倍）。不妨维护三个堆，第一个堆记录当前翻倍的咒语，第二个堆记录当前不翻倍的咒语，第三个堆记录当前不翻倍的火焰咒语。在每一次询问后的更新过程中，我们始终保持最大的$K$个咒语被翻倍，以此为前提对三个堆进行更新；但在回答询问之前，需要检查当前第一个堆中的咒语是否都是闪电咒语。如果都是闪电咒语，则利用第三个堆对结果进行更新。

::: spoiler 参考代码（C++）

<<< @/docs/editorial/codeforces/1398/src/e.cpp

:::

## Problem F - Controversial Rounds

### 题目描述

有一个长度为$n$的含有`'?'`的01字符串（`'?'`表示可以为0，也可以为1）。问通过对`'?'`的不同设置，最多能有多少个互不重叠的长度为$i$的连续子串？$i$从$1$取到$n$。

### 题解

对于长度$i$，如果我们可以在前$m$个字符中构成一个串，那么一定优于在前$m+1$个字符中构成一个串，也即应该尽可能往前安排。

因此，我们可以构建两个串$s$和$t$。$s$通过把原字符串中所有的`'?'`替换为`'0'`得到，$t$通过把所有的`'?'`替换为`'1'`得到。得到这两个串后，如果我们希望构建一个`'0'`的连续子串，我们就从$s$中选取；否则就从$t$中选取。

在$O(n)$时间内，我们可以预处理得到从每个位置开始的最长连续子串长度$p$和$q$。同时，我们可以预处理得到$s$串每个位置的下一个`'0'`串的起点$np$，以及$t$串每个位置的下一个`'1'`串的起点$nq$。

我们从长度为$1$的子串开始。对于每一个长度，我们首先从下标$1$开始，如果当前$p[idx]$和$q[idx]$中有一个满足要求，我们则尽可能地构建子串；如果两个都不满足要求，我们就移动到$np[idx]$和$nq[idx]$中的较小值，同时，如果当前位置等于上一个位置$last$的后指针$np[last]$或$nq[last]$，我们则相应地对$np[last]$或$nq[last]$进行更新（因为如果对于当前长度不行，那么对于下一个长度肯定也不行，所以下一次就可以直接跳过这一下标），这有些类似于并查集中的路径压缩。

::: spoiler 参考代码（C++）

<<< @/docs/editorial/codeforces/1398/src/f.cpp

:::

## Problem G - Running Competition

### 题目描述

有一个长为$x$，宽为$y$的矩形跑道，中间还有$n-1$条垂直的跑道。$n+1$条垂直跑道的位置为$x_0,\cdots,x_n$。

现在需要进行若干场比赛，每场比赛的总长度为$L_i$，要求选取两条垂直跑道，使得这两条跑道所围成的矩形的周长为$L_i$的因子，且尽可能大，输出这个长度。如果无解，输出$-1$。

### 题解

显然可以枚举出所有能够组成的跑道长度；对于之后的每一个询问，直接以$\sqrt{L_i}$的复杂度枚举因子即可。

如何枚举出跑道长度呢？暴力枚举的$O(n^2)$复杂度是不可接受的。

实际上我们需要枚举的是$x_j-x_i$，容易想到，我们可以构建两个多项式

$$f(x)=\sum_{i=0}^nx^{x_i}$$
$$g(x)=\sum_{i=0}^nx^{-x_i}$$

将这两个多项式相乘，得到的$f(x)g(x)$中系数大于0且阶数大于0的项，就是我们可以得到的跑道的长度，进而就可以得到所有可能的周长。

用FFT来计算即可。

::: spoiler 参考代码（C++）

<<< @/docs/editorial/codeforces/1398/src/g.cpp

:::

# Codeforces Round 661 (CF1399) 题解

## Problem A - Remove Smallest

### 题目描述

给定$n$个数，每次操作中，可以选取任意两个相差不超过$1$的数，然后删去其中一个，问能否删到只剩下一个数。

### 题解

先排序，然后从小到大遍历，判断较小的那一个能否被删除。

::: details 参考代码（C++）

<<< @/docs/editorial/codeforces/1399/src/a.cpp

:::

用FP的思想，就是要得到一个$b_i=a_{i+1}-a_i$的差数组，然后判断$b_i$的最大值是否超过$1$。

::: details 参考代码（Haskell）

<<< @/docs/editorial/codeforces/1399/src/a.hs

:::

## Problem B - Gifts Fixing

### 题目描述

有$n$个盒子，每个盒子里有$a_i$个A，$b_i$个B，每次操作可以从任意盒子里去除一个A或一个B或一对A+B，问至少多少次操作，可以让所有盒子中的A和B数量都相等？

### 题解

所有盒子的A都要以最少的A为准，所有盒子的B都要以最少的B为准。对于某一个盒子，需要的总操作次数等于A的差量和B的差量中较大的那一个。

::: details 参考代码（C++）

<<< @/docs/editorial/codeforces/1399/src/b.cpp

:::

这题的FP相对来说是比较容易实现的。

::: details 参考代码（Haskell）

<<< @/docs/editorial/codeforces/1399/src/b.hs

:::

## Problem C - Boats Competition

### 题目描述

将$n$（$n\leq50$）个体重分别为$w_i$（$w_i\leq n$）的人两两组队，要求每一组的体重总和相等，最多能分多少组？

### 题解

考虑到数据范围，直接枚举体重总和，然后计算每种体重总和下的最大配对数。当然，在枚举之前，首先要将体重数据有序化。这可以通过排序或哈希表两种方式来实现。

::: details 参考代码（C++）

<<< @/docs/editorial/codeforces/1399/src/c.cpp

:::

FP就递归处理就好了。

::: details 参考代码（Haskell）

<<< @/docs/editorial/codeforces/1399/src/c.hs

:::

## Problem D - Binary String To Subsequences

### 题目描述

有一个二进制串，问最少要将其分成多少个子序列，才能保证每个子序列都为$0$-$1$交替的形式？

输出需要的子序列的个数，以及每个元素所属子序列的编号。

### 题解

记录下一个待使用的编号，以及当前结尾为$0$的子序列的编号和当前结尾为$1$的子序列的编号。对于每一个元素，如果没有能与其匹配的子序列，就要申请一个新的子序列；否则就将其进行匹配，并将对应的子序列移入另一组（$0$到$1$，$1$到$0$）。

::: details 参考代码（C++）

<<< @/docs/editorial/codeforces/1399/src/d.cpp

:::

FP通过递归进行处理。

::: details 参考代码（Haskell）

<<< @/docs/editorial/codeforces/1399/src/d.hs

:::

## Problem E1 - Weights Division (easy version)

### 题目描述

有一棵根为$1$的树，每条边有权重，每次操作可以把任意一条边的权重从$w_i$变为$\left\lfloor\frac{w_i}{2}\right\rfloor$，问最少多少次操作，可以让根节点到所有叶子节点的路径权重和不超过$S$？

### 题解

显然通过DFS可以计算出每一条边影响的叶子节点数量，从而可以计算对每一条边进行操作的回报（减少的总权重）。那么，自然想到基于优先队列的贪心方法，每次操作都选择回报最大的那条边进行，这样得到的结果一定是最优的。

::: details 参考代码（C++）

<<< @/docs/editorial/codeforces/1399/src/e1.cpp

:::

## Problem E2 - Weights Division (hard version)

### 题目描述

大致与简单版本相同，但每条边额外增加了成本属性，成本为$1$或$2$，要求最后使用的总成本最低。

### 题解

在简单版本解答的基础上，改为使用两个优先队列，分别储存成本为$1$和成本为$2$的边。

当有一个队列为空时，显然应该从另一队列中取边进行操作。

如果两个队列都非空，则需要进行比较。
- 情形一：使用一条成本为$1$的边就可以满足要求，此时显然应该选择这条边。
- 情形二：比较对成本为$1$的优先队列连续操作两次的回报，与对成本为$2$的优先队列操作一次的回报。如果前者大于后者，则对优先队列$1$进行**一次**操作；否则对优先队列$2$进行一次操作。要注意，这里不能对优先队列$1$连续进行两次操作，因为第二和第三次操作的总回报可能小于对优先队列$2$操作一次的回报。

::: details 参考代码（C++）

<<< @/docs/editorial/codeforces/1399/src/e2.cpp

:::

## Problem F - Yet Another Segments Subset

### 题目描述

有$n$（$n\leq3000$）个区间$[l_i,r_i]$，要求从中选出尽可能多的区间，使得选出的区间中任意两个均相离或相含，问最多能选出多少个区间。

### 题解

从最大独立集（最大团）的角度考虑，这是个NP问题，但如果我们利用区间的性质，是可以在多项式时间解决本题的。

从数据范围看，$O(n^2)$的算法就可以接受，因此考虑进行区间DP。

第一步当然是离散化，离散化之后，区间端点的范围为$[0,6000)$。

DP的顺序自然是从短的区间到长的区间，因为长的可以覆盖短的。接下来的问题是如何进行转移。

对于当前区间$[L,R]$：

- 如果存在一个对应的区间，显然应该将其选中
- 如果不使用从$L$开始的区间，那么最优的显然是$[L+1,R]$
- 如果使用从$L$开始的区间，那么我们需要枚举所有从$L$开始且右端点小于$R$的区间，假设当前枚举到的区间为$[L,R']$，我们能够得到的额外区间数就是$[L,R']+[R'+1,R]$

最后的结果就是$[0,M-1]$（$M$是离散化后点的总数）。

::: details 参考代码（C++）

<<< @/docs/editorial/codeforces/1399/src/f.cpp

:::

<Utterances />

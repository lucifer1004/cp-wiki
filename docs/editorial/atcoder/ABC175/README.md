# AtCoder Beginner Contest 175 题解

## Problem A - [Rainy Season](https://atcoder.jp/contests/abc175/tasks/abc175_a)

过水，略。

## Problem B - [Making Triangle](https://atcoder.jp/contests/abc175/tasks/abc175_b)

### 题目描述

给定$N$根长度分别为$L_i$的棍子，问能组成多少个三边长度各不相同的三角形？如果两个三角形至少用了一根不同编号的棍子，则称它们是不同的三角形。

### 题解

本题的范围很小（$N\leq100$），所以可以在对棍子长度排序后（这样保证最后一个是最长边，只需要检查一次就能确定是否能构成三角形），直接枚举所有三元组，然后检查是否满足条件。

进一步地优化，可以在固定最长边的基础上，用双指针确定另外两条边的可选范围，时间复杂度可以降低到$O(N^2)$。

## Problem C - [Walking Takahashi](https://atcoder.jp/contests/abc175/tasks/abc175_c)

### 题目描述

有一个数$X$，对它进行$K$次$+D$或$-D$的操作，求操作后的$\min|X'|$。

### 题解

首先$X$的正负不影响结果，所以我们可以只考虑$|X|$。

如果$|X|>D$，那么我们首先应该向原点移动，直到$|X'|<D$。这时还剩下$K'$次操作，我们应当在原点的左右两侧来回移动。根据$K'$的奇偶判断一下最后在哪一个位置即可。

## Problem D - [Moving Piece](https://atcoder.jp/contests/abc175/tasks/abc175_d)

### 题目描述

有$N$（$N\leq5000$）个方格，从第$i$个方格会跳到第$P_i$个方格。$P$是$1,\cdots,N$的一个排列。

每个方格上写了一个数字$C_i$。每次跳跃时，会得到等同于$C_{P_i}$的分数。你可以从任意方格开始，跳跃至少一次，至多$K$次，求能够取得的最高分数。

### 题解

枚举起点。由于$P$是排列，所以我们从任意位置$i$开始，经过若干次跳跃后一定会回到$i$。我们可以计算出一个周期内的前缀和。然后，根据周期长度$C$与$K$之间的关系，分情况讨论。

- $K\leq C$，此时我们应该选择前$K$个前缀和中的最大值。
- $K>C$，令$K=nc+r$，则我们可以选择
    - 不循环，选择所有前缀和中的最大值。
    - 循环$n$次，再加上前$r$个前缀和中的最大值。
    - 循环$n-1$次，再加上所有前缀和中的最大值。

总时间复杂度$O(N^2)$。

::: spoiler 参考代码（C++）

<<<@/docs/editorial/atcoder/ABC175/src/d.cpp

:::

思考：如果$N\leq10^5$，应该如何改进算法？

::: spoiler 提示一

在上面的算法中，对于一个循环，设其长度为$L$，我们实际上重复计算了$L$次（针对每一个起点）。有没有可能减少这样的重复计算呢？

:::

---

::: spoiler 提示二

在每一个循环内，问题实际上可以转化为，给定一个由$L$个数围成的圈，从中取出长度不超过$K$的一段连续串，求能取得的最大和。

:::

---

::: spoiler 提示三

前缀和+RMQ。

::: 

---

::: spoiler 参考代码（C++）

<<<@/docs/editorial/atcoder/ABC175/src/d2.cpp

:::


## Problem E - [Picking Goods](https://atcoder.jp/contests/abc175/tasks/abc175_e)

### 题目描述

$R$行$C$列的方阵，其中有$K$个格子里有东西，第$i$个东西的价值为$v_i$。从左上角走到右下角，只能向下或向右走，限定每行最多拿$3$个东西，求能取得的最大价值。

### 题解

在常规的方阵DP基础上再加一维记录当前行取了几个东西即可。因为$3$是常数，所以总时间复杂度为$O(RC)$。

::: spoiler 参考代码（C++）

<<<@/docs/editorial/atcoder/ABC175/src/e.cpp

:::

## Problem F - [Making Palindrome](https://atcoder.jp/contests/abc175/tasks/abc175_f)

### 题目描述

有$N$（$N\leq50$）个长度不超过$L$（$L\leq20$）的字符串，每个字符串可以使用无限次，第$i$个字符串使用一次的代价为$C_i$。问最少花费多少代价，能够用这些字符串组成一个回文串？或者说明无解。

### 题解

直接搜索，状态似乎是无穷无尽的。如何减少状态空间，让搜索变为可能？

我们考虑从左右两边分别构建字符串。最开始，左边和右边都是空的。我们希望最后能将左边部分和右边部分进行匹配。这里，匹配的意思是，对于串$A$和$B$，两串中较短的那串是较长那串的子串。在匹配之后，如果剩下的部分是一个回文串（或为空），则我们就成功构建了一个回文串。

我们每次可以把某个字符串加入到左边或右边，这样就得到一个中间状态。在转移过程中，我们应当保证始终只有至多一边有未匹配部分，而其余部分都应该得到匹配。也就是说，如果当前左边有未被匹配的部分，我们就把新字符串添加到右边；反之亦然。

从而，我们只需要保存当前未被匹配的部分。而因为我们总是在相反的一边添加，这里的未被匹配部分必定为原来某个字符串的前缀或后缀。这样，我们就把总状态数限制到了$O(NL)$。

此时，原题就变成了一个最短路径问题。因为数据范围很小，可以用各种最短路径算法来求解。

::: spoiler 参考代码（C++）

<<<@/docs/editorial/atcoder/ABC175/src/f.cpp

:::

<Utterances />

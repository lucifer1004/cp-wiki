# Google Kick Start 2019 Round C 题解

## Problem A - [Wiggie Walk](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ff2/0000000000150aac)

### 题目描述

有一个机器人在方格上按照指令行走，如果当前格子之前已经走过，它会按照指令继续向前走，直到走到一个没走过的格子。给定机器人的起始位置和指令，保证过程中机器人不会碰到方格的边界，求机器人的最终位置。

### 题解

把每行每列已经走过的区间用集合存储，则我们只需要实现两个操作：

- 给定起始位置（行、列）和方向，找出下一个空位置
- 将走到的新位置加入所在行和列的区间集合

::: details 参考代码（C++）

<<< @/docs/tutorial/kick-start/2019C/src/a.cpp

:::

## Problem B - [Circuit Board](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ff2/0000000000150aae)

### 题目描述

给定一个矩阵，从中划出一个矩形，要求矩形每行的最大值和最小值之差都不超过$K$，求矩形的最大面积。

### 题解

分两步实现。首先对每行进行预处理，得到以$(i,j)$结尾的最长的符合要求的串的长度。接下来对每列求最大矩形面积。

如果第一步使用`set`来维护当前区间的最大和最小值，则总时间复杂度为$O(RC\log C)$。

::: details 参考代码（C++，使用set）

<<< @/docs/tutorial/kick-start/2019C/src/b1.cpp

:::

如果改为用两个单调队列，则总时间复杂度为$O(RC)$。

::: details 参考代码（C++，使用单调队列）

<<< @/docs/tutorial/kick-start/2019C/src/b2.cpp

:::

## Problem C - [Catch Some](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ff2/0000000000150a0d)

### 题目描述

在一条直路上有$N$条狗，每条有一个颜色。小明想要观察$K$条狗（不能重复），他必须穿着相同颜色的衣服才能观察某条狗，只有在家（原点）他才能换衣服。

问小明从家出发，观察$K$条狗所需要的最短路程。

### 题解

显然，如果一个计划中包含了多条同种颜色的狗，应当一次性对这些狗进行观察。另一方面，应当优先观察位置最靠前的具有该种颜色的狗。

不难发现，只有最后一次有区别，因为最后一次不需要回头，只用计算一倍路程，而之前的都需要计算双倍路程；而具体先看哪种颜色后看哪种颜色对结果并没有影响。

直接的想法是枚举最后一次看的狗的颜色然后进行$N$次动态规划，这样复杂度就多了一个$N$，但是如果代码有一定优化，也可能通过大测试集。

更好的办法是在动态规划中加一个标志位，$dp[i][0]$表示当前看了$i$条狗，还没有进行最后一次观察的最短路程；$dp[i][1]$表示当前看了$i$条狗，已经进行了最后一次观察的最短路程（我们可以假想把最后一次观察提到前面进行）。

::: details 参考代码（C++）

<<< @/docs/tutorial/kick-start/2019C/src/c.cpp

:::

<Utterances />
